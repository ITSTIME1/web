
// let 과  var의 차이를 좀 알아보자.
// 우선 let 과 var 둘다 변수를 지정하는 타입이라는것이다.

// 둘의 차이점은?

// let 은 block scope 라고 해서 블록 범위로 제한되어 지는 것이다.
// 가령 아래 예를들어보자면
// 전역변수로 let x 를 선언했다고 해보자 현재 x에는 1값이 할당되어져있고,
// if 문 {} block scope 는 이 bracket 을 지징한다
// 이 bracket 안에 x에 똑같은 네이밍의 변수를 지정하고 값을 할당했을대
// {} 안에서는 x의 값이 바뀐것을 확인할 수 있다./
// 그렇다면 {} 밖에서 x를 호출하면 어떻게 될까 
// 우리가 알고 있는 전역변수는 어디에서든 값의 접근이 가능하고 접근이 가능해서
// 변수의 값을 바꿀 수 있다/
// 하지만 let은 다르다
// let은 block scope 내에서 변수의 값이 변경이 되어지고 나서
// {} 밖에서는 변경된 값이 출력되지 않는다.

// 이걸 mdn에서는 이렇게 설명하고있다.
// "ley allows you to declare variable that are limited to the scope of a block statement."
// 즉 블럭스코프 상태에서만 변경이 허용되어진다는 뜻이다.
// 때문에 아무리 전역변수로 설정을 해두었다고 하더라도
// bracket 내부에서 변경이 일어난건 그 bracket 내에서까지만 제한한다는것이다.


// var는 글로벌, 로컬 관계없이 접근이 가능하다.
// var 키워드 자체가 일반적으로 값을 할당하고 출력하는 기본적이고 익숙한 구조라고 생각하면 된다.
let x = 1;

if (x === 1) {
  let x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 1


function varTest() {
    var x = 1;
    {
      var x = 2;  // same variable!
      console.log(x);  // 2
    }
    console.log(x);  // 2
}


// 이런구조를 함수 선언문 이라고하고
function letTest() {
    let x = 1;
    {
      let x = 2;  // different variable
      console.log(x);  // 2
    }
    console.log(x);  // 1
}


// 아래와 같은 구조를 함수 표현식 이라고한다.
// 함수표현식에서는 함수의 이름을 생략할 수 있다.
// 그럼 함수 이름을 작성한다면?
var add2 = function add2(a, b) {
    return a + b;
}
var add = function(a, b) {
    return a + b;
}


// 함수 생성자 함수가 있다.
var add3 = new Function('x,', 'y', 'return x+y');

// 람다식처럼 작성하는것도 있다.
var add4 = (x, y) => x + y

// 그럼 함수표현식과 함수선언문의 호이스팅을 했을시 차이점이 무엇일까?

// 먼저 함수선언문은 자바스크립트 엔진에서 먼저 실행되어
// 함수 자체를 호이스팅 시킬 수 있다.
// 하지만 함수표현식은 변수를 호이스팅 했을시 선언단계에서 undefined로만 할당이 되어지고
// 실제값은 할당이 되어져 있지 않다.
// 함수표현식에서 호이스팅도 마찬가지로 함수를 참조하는 순간 undefined 로초기화만 시키고
// 값의 할당이 이루어지는 시점 var add = function() 이 시점에서 실제 파라미터의 값을 받고
// 값을 할당시키는 객체가 되어진다.

// 위에서 스코프라는 말을썼는데 스코프는 함수나 변수의 유효범위를 뜻한다.
// 다시말해 그 변수가 어디까지 유효한가 그 함수는 어디까지 유효한 함수인가를 나타낼때 표현하는 단어이다/



// var 와 let 중 const, let을 사용하는걸 권장하는데
// 그 이유가 var키워드는 함수레벨 스코프 뿐만아닌 전역변수로 지정해둔다면
// 어디에서든 값의 변경이 일어날 수 있다.
// 때문에 이전의 할당된 값이 자유롭게 바뀌어질 수 있다는 것이다.

// 코드가 유지보수하기 쉽고, 짧다면 문제를 바로 찾아낼 수 있겠지만
// 코드가 길어지고 유지보수하기 쉽지 않다면 문제가 어디서 났는지 빠른시간안에 파악하기가 비교적 힘들것이다.
// 이런상황이 온다면 변수의 값을 다 체크해봐야 하고, var 키워드로 선언된 변수의 flow를 따라가야만 찾을 수 있따.
// 그렇기 때문에 let, const 를 사용한다면 특히 var->let 을사용한다면
// 스코프 범위를 벗어나지 않도록 변수의 범위를 좁혀
// 해당 함수에서만 값을 변경하고 나머지 스코프에서는 지정해두었던 값으로 사용하게끔 한다면
// 해당 스코프부분에서만 문제를 찾으면 되기 떄문에
// 비교적 오류를 찾아내기 쉬울것이다.

// const 같은 경우 constant 상수라는 뜻이기에 한번 값이 할당되어진다면 변경이 되어지지 않는다.
// 때문에 변경이 필요없는 혹은 변경을 하지 않아야하는 변수가 있다면 const 값을 사용하면 될것이다.

// var 에서는 문제가 있었는데
// 변수를 중복선언이 가능하다
// 함수레벨 스코프로 인해 외부에서 선언한 변수는 모두 전역변수로 취급한다
// 그렇기 때문에 값의 변경이 쉬워진다.


// 변순선언문 이전에 변수를 참조하면 undefined 값을 반환한다.


// let 은 변수중복선언이 불가능하다.
// let a = "d", let a = "b"
// 위와 같은 형태는 불가능하다.
// 하지만 a = "taesun" 과 같이 변수의 재할당은 가능하다.

// const는 선언과 동시에 초기화가 진행되어야한다.
// 착각하면 안되는게 객체의 값을 변경하는건 가능하다.
// 재할당이라는게 한번 선언된다면 그 값을 다른 값으로 할당시키는게 불가능하다는것인데
// const name = "d"
// const name = {eng:"korea"}
// 와 같이 객체에서 값을 변경하는 행위는 허용한다.


